


<div align="center"> <img src="https://github.com/LiuChuang0059/ComplexNetwork-DataMining/blob/master/Recommendation_Agorithm/Image/%E8%BF%91%E9%82%BB%E6%8E%A8%E8%8D%90%E6%80%BB%E7%BB%93.jpg" width="600"/> </div><br>
 


----------
# 1. 协同过滤
  > 协同过滤的核心是用户物品关系矩阵

* 基于记忆的协同过滤
> 记住消费过的物品，推荐相似的东西，或者推荐相似的人的消费的东西

* 基于模型的协同过滤
> 从用户物品关系矩阵中学习一个模型，从而把矩阵的空白处填满


-------


# 2. 基于用户的协同过滤

* 1. 准备用户向量
    * 向量的纬度是物品的数量
    
* 2. 使用用户向量，计算两两用户之间的相似度，设定一个相似度阈值，

* 3. 为每一个用户产生推荐结果
  > 聚类相似的用户喜欢的用品汇总起来，去掉用户已经消费过的物品，剩下的排序 就是推荐结果

计算公式：


<div align="center"> <img src="https://github.com/LiuChuang0059/ComplexNetwork-DataMining/blob/master/Recommendation_Agorithm/Image/%E6%8E%A8%E8%8D%90%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F.png" width="400"/> </div><br>

* P 是计算每一个物品 和用户之间的匹配分数

* 分母是 把和用户u相似的n个用户的相似度加起来

* 分子 是： n 个用户对商品的态度 按照相似度加权平均。





### 1. 构造矩阵

协同过滤计算，使用的矩阵是稀疏的，稀疏矩阵的典型储存格式

*  CSR 整体编码 = 数值 列号 行偏移
* COO 每个元素使用三元组表示 （行号，列号，数值）

### 2. 相似度计算

1. 向量很长--降低计算复杂度

* 对向量采样计算--- Twitter ： DIMSUM算法 ；在Spark中实现

* 向量话计算  ： 避免循环，转换成向量


2. 用户量很大，两两之间的计算代价很大

* 相似度计算拆分成 Map Reduce 任务，将原始矩阵成建为 用户对， 值为两个用户对同一个物品分评分之积

*  数据量不超过百万，矩阵稀疏， 单机工具： KGraph， GraphCHI



### 3. 推荐计算

**计算过程拆分成Map Reduce 任务**--- 使用多线程技术实现Map的效果： C++ 的 OpenMP 库，使用多线程。

具体拆分：

* 1. 遍历每个用户喜欢的物品列表

* 2. 获取该 用户的相似性用户列表

* 3. 把每一个喜欢的物品 Map 成两个记录发射出去，一个是键为 < 相似用户 ID，物品 ID，1> 三元组，可以拼成一个字符串，值为 < 相似度 >，
另一个是键为 < 相似用户 ID，物品 ID，0> 三元组，值为 < 喜欢程度 * 相似度 >，其中的 1 和 0 为了区分两者

* 4. Reduce 阶段，求和后输出；

* 5. < 相似用户 ID，物品 ID, 0> 的值除以 < 相似用户 ID，物品 ID, 1> 的值


### 4. 改进

> 改进集中在 用户对物品的喜欢程度上

*  惩罚对热门物品的喜欢程度， 热门的东西很难反应用户端额真是兴趣，无聊随便点击，群体行为常见特点

* 增加喜欢程度的时间衰减，使用一个指数函数，指数是一个负数

------


# 3. 基于物品的协同过滤

1. 物品的数量少于用户的数量；

2. 物品之间的相似度 静态，变化的速度没有用户的口味变化快

3. 计算物品之间相似度稀疏度是好过计算用户之间的相似度的


* 计算步骤

1.  构建用户物品的关系矩阵，  ： 用户的消费行为，消费后的评价，消费行为的量化： 时间，次数，费用

2.  计算得到物品相似度的矩阵

3.  产生推荐结果



 ### 1. 计算物品之间的相似度
 
 
 * 物品向量： 稀疏向量，纬度是用户， 各个纬度的取值是，对这个物品的消费结果，行为本身的布尔值
 
 * 两两计算物品的相似度 ： 余弦相似度
 
 
 改进物品之间的相似度
 
 * 物品中心化，
 > 计算 每一个物品收到的评分的平均值，物品向量中的分数减去对应物品的均值。（去掉物品中铁杆粉丝群体的非理性因素）
 
 * 用户中心化
 > 计算每一个用户的评分均值，打过的所有分数都减去这个均值
 
 
 ### 2. 计算推荐结果
 
 #### 1. TopK 推荐--- 猜你喜欢
 
 > 汇总和用户已经消费过的物品的相似物品----- 使用相似度加权汇总 （按照用户评分过的物品，逐一取出和他们相似的物品）
 
 
 #### 2. 相关推荐 --- 类似于 ”看了又看“
 
 **Slope One算法** --- 解决评分矩阵
 实时更新 ？？？
 
 
 

 
 -------
 
 
 # 4. 相似度计算方法
 
 ### 1. 欧式距离
 
 * 坐标向量之差
 * 因为得到的值是正的 很大 ，需要二次转化 （➕1后取倒数）---  转化为0-1
 
 > 用于分析用户能力模型之间的差异
 
 ------
 
 ### 2. 余弦相似度
 
 余弦相似度的计算 与向量的长度无关---- 计算对向量的长度进行归一化
 **思想： 两个向量，只要方向一直，无论程度强弱，都可以视作 相似**
 > 例如： 140字的微博摘要了一篇5000字的博客内容，文本向量认为方向一致，词频程度不同，（检查重复--缩写摘要论文）
 
 
 对绝对值大小不敏感--问题
 >  A 对两部电影的评分 1，2     B对两部电影的评分 4，5 余弦相似度极速哪出来，相似度 98% 不符合
  
 **改进-- 调整的余弦相似度**
 
 先计算向量每个纬度上的均值向量各个纬度上减去均值
 
 
 ------
 
 ### 3. 皮尔逊相关度

<div align="center"> <img src="https://github.com/LiuChuang0059/ComplexNetwork-DataMining/blob/master/Recommendation_Agorithm/Image/%E7%9A%AE%E5%B0%94%E9%80%8A%E7%9B%B8%E5%85%B3.png" width="400"/> </div><br>
 
 
 
 皮尔逊相关计算的是两个变量变化的趋势是否一致
 
 
 -------
 
 ### 4. jaccard 相似度 --- 适合布尔向量
 
 两个集合的交集元素的个数在并集中所占的比例 
 
 * 分子是两个布尔向量做点积运算--- 交集元素的个数
 * 分母是 两个布尔向量做 或的运算， 求和
 
 **适用于隐式反馈：计算用户的收藏行为**
 
 
 -------
 
 
 
 
 
 
 
 <div align="center"> <img src="https://github.com/LiuChuang0059/ComplexNetwork-DataMining/blob/master/Recommendation_Agorithm/Image/%E8%BF%91%E9%82%BB%E6%8E%A8%E8%8D%90%E6%80%BB%E7%BB%93.jpg" width="600"/> </div><br>
 
 
 
 
 
 
 
 

















