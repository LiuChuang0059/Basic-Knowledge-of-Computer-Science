

<div align="center"> <img src="https://github.com/LiuChuang0059/ComplexNetwork-DataMining/blob/master/Recommendation_Agorithm/Image/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3%E6%80%BB%E7%BB%93.jpg" width="800"/> </div><br>






# 1. 为什么使用矩阵分解

近邻模型的问题：

1. 物品之间存在相关性，信息量并不随着向量的纬度增加而 线性增加；？？？
2. 矩阵元素稀疏，计算结果不稳定，增加一个向量纬度，导致近邻结果差异很大

# 2. SVD算法

## 1. 基础的SVD算法

1. 将用户和物品都映射到一个 k 维空间，k 维空间不一定具有很好的解释性，维度成为隐因子

2. 用户向量 p ， 代表用户在若干因素的偏好（k）； 对于物品向量 q ：物品 背后暗藏的一些用户关注的因素

3.  用户的向量是pu  物品的向量是qi  物品推荐给用户的推荐分数是 二者的点积

4. 计算 k 维向量 --- k 由 K-fold确定
* 损失函数
* 优化算法

<div align="center"> <img src="https://github.com/LiuChuang0059/ComplexNetwork-DataMining/blob/master/Recommendation_Agorithm/Image/%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89.png" width="800"/> </div><br>

* 前部分 计算预测误差 
* 后部分，减小隐因子的向量，控制模型的方差-------- 正则化

5. 整体的学习过程

  * 评分数据
  * 分解矩阵，随机初始化元素
  * 利用矩阵预测 ，计算误差函数
  * 梯度下降，确定矩阵的元素值


-------

## 2. 增加偏置信息

> 避免一些 偏高的 评分

**抽取偏置信息的SVD**

评分会由四部分相加 = 全局平均分， 物品的评分偏置（与平均分的比较），用户评分偏置（与平均分的比较） ，用户和物品之间的兴趣偏好（点积）


<div align="center"> <img src="https://github.com/LiuChuang0059/ComplexNetwork-DataMining/blob/master/Recommendation_Agorithm/Image/%E5%81%8F%E7%BD%AE%E4%BF%A1%E6%81%AF%E7%9A%84SVD%E3%80%81.png" width="800"/> </div><br>




-----

## 3. 增加历史信息

结合 用户的隐式反馈和属性---SVD++

* 假设评分矩阵中的物品有一个隐因子向量，
* 用户行为的物品集合 也有一个隐因子向量，纬度相同---- 操作过的物品的隐因子向量加起来，表达用户的兴趣偏好

* 对于用户属性，全部转化成 0，1 特征后， 提取同样纬度的隐因子向量，所有属性的隐因子向量相加和，表达用户的兴趣偏好

用户向量增加用户属性向量 和 隐式反馈向量

<div align="center"> <img src="https://github.com/LiuChuang0059/ComplexNetwork-DataMining/blob/master/Recommendation_Agorithm/Image/SVD%2B%2B.png" width="800"/> </div><br>

--------

## 4. 考虑时间因素

1.   对评分按照时间加权，久远的评分更趋近于平均值

2. 对评分时间划分区间，不同的时间区间内学习出的隐因子向量，使用按照区间的对应的隐因子向量来计算

3. 特殊的期间， 节日，周末等训练对应的隐因子向量

------------

# 3. 交替最小二乘（ALS）

1. 随机初始化 Q， 线性代数，求解 逆矩阵 P

2. 将 P 看作 已知的，，利用误差函数，优化参数 求解出Q

3. 交替进行，满足误差阈值


Pros： 不是很稀疏的矩阵上，ALS 效果更好一点


-------

# 4. 隐式反馈

行为预测模型： One - Class数据

> 预测用户行为看作是一个 二分类的问题， 猜测用户会不会去做某事，但是实际上收集的数据只有明确的一类： 用户做了某事，而用户不做某事的数据没有表达

隐式反馈的矩阵分解--- Weight- ALS 加权交替最小二乘



* 行为的次数是 对行为置信度的反应，即是 所谓的加权
  * 用户对物品无隐式反馈 则认为评分是 0；
  * 用户对物品至少有一次隐式反馈 则认为评分是1 ； 次数作为评分的置信度
  
<div align="center"> <img src="https://github.com/LiuChuang0059/ComplexNetwork-DataMining/blob/master/Recommendation_Agorithm/Image/%E7%BD%AE%E4%BF%A1%E5%BA%A6%2B.png" width="800"/> </div><br>

其中置信度 Cui = 1 + a* C  (C 是次数，a是超参数，默认取值40 )
  
  
**问题**

没有反馈的缺失值，设定为0 ，这样会导致取值为0 的评分非常多，政府样本非常不平衡，严重倾斜到 0 评分的一边

目的就是填充缺失值，所以不应该全部是 0 


**Solve**

按照物品的热门程度进行填充
>  什么样的适合选作负样本，----> 展示给用户，用户意识到存在，但是没有反馈。，，但是 问题是不知道用户有没有意识到物品的存在，
因此，按照物品的热门程度来的话，越热门，用户越可能知道他的存在，这种情况，还是没有反馈，这是真正的负样本

-----



# 5. 推荐计算

* 得到 用户的隐因子向量（稠密向量） --代表兴趣
* 物品的 稠密向量，代表他的语义或者主题

**解决计算复杂度**

* 专门设计数据结构储存所有物品的隐因子向量，一个用户返回最近似的k个物品
开源 Faiss  ，Annoy ,Kgraph ,NMSLIB
> 动态增加 物品向量 --Faiss ;;  不是的话： NMSLIB 或者 Kgraph

*  物品的隐因子向量先做聚类分析，再逐一计算用户和每个聚类中心的推荐分数，给用户推荐物品聚类
得到推荐的聚类后，， 再从每个聚类中挑选少许的几个物品作为推荐结果

-------

# 6. 矩阵分解的不足


## 1. Point-Wise 
> 只单独考虑每个物品，每个物品像是空间中孤立的点一样。
只能收集正样本，没有负样本，认为缺失值就是负样本，再以预测误差来逼近这些样本



## 2. pair-wise
> 直接预测物品两两之间相对顺序的问题


------

# 7. 贝叶斯个性化排序

1. 关注相对的排序 -- 使用AUC（Area Under Curve） 作为评价指标 ----曲线下的面积（ROC曲线）

2. AUC 等价于： 模型把关心的那一类样本排在其他样本前面的概率，最大是1 ，0.5 就是随机排列


3. BPR 具体

### 1. 构造样本
 BPR 关心的是 物品之间相对用户的相对顺序，样本（用户，物品1，物品2 ，两个物品的相对顺序）

*  物品1 是消费过的，2 不是 相对顺序取值为1 ， 是正样本
* 如果相反， 则是负样本
* 样本中不包含其他情况： 都消费过或者都没消费过

学习的数据是反应用户偏好的相对顺序，使用的时候，面对的是所有用户还没消费过的物品，这些物品荏苒可以在这样的模型下得到相对的顺序？？？

### 2. 目标函数

1. 最大化交叉熵--目标函数
2， 防止过拟合，加入正则项---- 认为模型参数有个先验的概率，

3. BPR 认为模型的先验概率符合正态分布


### 3. 训练方法

* 批量梯度下降 --- 收敛慢 
* 随机梯度下降 --- 训练快 却不稳定

* 重复抽样的梯度下降
 1. 全样本随机抽取一部分样本
 2. 使用这部分样本 SGD 更新参数模型
 3. 重复
 
 
 --------
 
 















































































































