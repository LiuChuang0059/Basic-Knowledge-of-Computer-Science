
* 本文主要内容为**刘超**老师在极客时间上的《趣谈网络协议》课程学习笔记

----

> HTTP 协议 ： 上网协议


## 1.  HTTP1.1

### 1. HTTP 请求准备

* 浏览器将 域名 （例如： www.163.com ）发送给 **DNS 服务器** 让他解析为 IP 地址。

* HTTP 基于 TCP ； 首先建立 TCP 连接
> 由于 HTTP 默认开启了 Keep-Alive， 这样建立的 TCP 连接可以在多次请求中复用

----


### 2. HTTP   请求的构建

* 建立连接之后，浏览器发送 HTTP 请求。

请求格式

![](https://github.com/LiuChuang0059/large_file/blob/master/pic/2sfde.jpg)

#### 1. 请求行

* URL 是 http：//www.163.com ，

* 方法 有几种常用的类型 ：

> 访问网页： **GET** ； 去服务器获取一些资源， 例如：网页，JSON 字符串
>  **POST** : 主动告知服务端一些信息
>>> 例如 支付的时候，客户端就需要把 个人信息，支付金额等信息告诉服务器
> **PUT** 向指定的资源位置上传最新的内容
>>> 实际上使用的时候，HTTP 的服务器往往不允许上传文件， POST 用来创建一个资源，PUT 用来修改一个资源
> **DELETE** : 删除资源

#### 2. 首部字段


* Accept-Charset： 表示客户端可以接受的字符集

* Content-Type : 表示正文的格式，例如 JSON

* 缓存
> 对于一个页面，会有很多数据，每次更新数据有些静态资源不一定要每次都更新
![](https://github.com/LiuChuang0059/large_file/blob/master/pic/1l995.jpg)
* Nginx 处理 HTTP 协议， 对于静态资源，有 Vanish 缓存层，当缓存过期的时候，才会访问 Tomcat 应用集群

	* Cacha-control  用来控制缓存
	> 例如客户端发送的请求中包含 max-age， 如果缓存层中，资源的缓存时间数值小于 max-age ，客户端可以接受缓存的资源，如果 age = 0 ； 缓存层将请求直接转发给应用集群

	* If-Modified-Since : 如果服务器的资源更新了，那么客户端也应该下载最新的资源

----

### 3. HTTP 请求的发送

1. 使用面向连接的方式发送请求， 通过 Stream 二进制流的方式传送， 传送到 TCP 层， 二进制流转化成一个报文段发送给服务器。

2. 发送每个报文段， 都需要对方一个回应 ACK ，保证报文的准确到达。

3. TCP 层 发送报文，需要加入自己的地址，和目的地址，地址再加入到 IP头里面，交给 IP 层进行传输

4.  IP 层查看目标地址和自己是否在 同一个局域网里面 ？
 	* 如果是 发送 ARP 协议请求目标地址的 MAC 地址，将源 MAC 地址和目标 MAC 放入 MAC 头，发送出去
 	* 如果不是， 需要发送网关，使用 ARP 协议获取网关的 MAC 地址，放入MAC 地址发送出去；网关首发哦包发现 MAC 符合，取出 IP地址，根据协议找到下一跳的路由器，获取下一跳路由器的 MAC 地址，包发给下一跳路由器
 	； 一跳一跳到达目的局域网， 在局域网发送 ARP ，获得 目标地址的 MAC地址发送

 5. 目标机器发现 MAC 地址符合，将包收起来，发现 IP 地址符合，根据 IP 头中的协议，知道上一层是 TCP 协议，解析 TCP 的头，；打开序列号，判断序列包是不是需要的，如果是就放入缓存中返回 ACK

 6. TCP 里面包含端口号， HTTP 的服务器正在坚挺这个端口号；目标机器知道是HTTP 服务器这个进程需要这个包， 将包发送给 HTTP 服务器。HTTP 服务器的进程看到，知道请求是访问一个网页，将网页发送给客户端。

 ----

### 4. HTTP 返回

![](https://github.com/LiuChuang0059/large_file/blob/master/pic/175ni.jpg)

#### 1. 状态码： 反应 HTTP 请求结果
* 200 意味着 一切顺利
* 404 意味着 服务端无法响应这个请求
* 503 服务暂时不再和 Retry-After 一起使用

#### 2. 短语 ： 大概叙说一下原因


#### 3.  首部的 Key-Value

* Retry-After : 客户端应该在多长时间后再次尝试

* Content-Type ： 表示返回 HTML 还是 JSON


#### 4.  发送 HTTP 的 返回报文

* 报文交给 Socket 发送，交给 TCP 层，让 TCP 层将返回的 HTML 分成一个个小的段，保证每个段都可到达

* 类似于上文，反向过程走一遍，一直到达客户端

* 客户端发现 MAC 地址符合 IP地址符合，交给 TCP 层，判断序列号是不是自己需要的报文段，如果是，根据 TCP 的端口号，发给相应的进程。 进程就是浏览器，浏览器作为客户端监听端口

* 浏览器 收到 HTTP 的报文，如果是 200 ， 就从正文中拿出 HTML，展示网页


-----

## 2. HTTP 2.0

* 2.0 对 HTTP 的头进行一定的压缩，将原来每次都要携带的大量 key value 在两端建立一个索引表，对相同的头只发送索引表中的索引

* 一个 TCP 连接，切分成多个流， ，每个流都有自己的 ID，并且分优先级

* 将 所有的传输信息分割为更小的消息和帧， 帧可以打散乱序发送，然后根据每个帧的首部流标识符重新组装并且可以根据优先级，决定优先处理哪个流的数据

* HTTP1.0 请求是串行的，使用 HTTP2.0 ，在一个连接里面客户端和服务端都可以同时发送多个请求和回应，而且不用按照顺序一一对应



![](https://github.com/LiuChuang0059/large_file/blob/master/pic/i20lc.jpg)

* HTTP 2.0 将三个请求变成3个流，数据分成帧，乱序发送到一个 TCP 连接之中
![](https://github.com/LiuChuang0059/large_file/blob/master/pic/5if6g.jpg)


-----


## 3. QUIC 协议

* HTTP 2.0 协议增加了并发性，但是因为也是基于 TCP 协议， 处理包的时候有严格的顺序，一个数据包遇到问题的时候，需要等待这个包完成重传才能继续进行

### 1.自定义连接机制

* 一条 TCP 连接是由四元组标识的，分别是 源 IP，目的 IP， 源端口，目的端口，一个元素发生变化，就需要断开重新连接，信号不稳定，网络切换，导致重连，导致时延。

* 在 QUIC 之中， 不再以四元组标识， 而是以一个 64位的随机数作为 ID 来标识，UDP 无连接，只要 ID不变，就不需要重新连接


### 2. 自定义重新连接

* QUIC 定义了 offset 的概念，数据在数据流里面有一个 偏移量，通过 offset 查看数据发送位置


![](https://github.com/LiuChuang0059/large_file/blob/master/pic/0xxzw.jpg)


### 3. 自定义流量控制

* QUIC 的 ACK 是基于 offset，offset包进来，进入缓存，可以应答

> TCP 的 ACK 机制基于序列号的累积应答，ACK一个序列号，就能说明前面的都到了，所以，一旦有一个每个后面的到了也不能 ACK；导致后面的到了也可能超时重传，浪费带宽。而 QUIC 中间可以村子啊空档

![](https://github.com/LiuChuang0059/large_file/blob/master/pic/kuk43.jpg)


-------


































































































