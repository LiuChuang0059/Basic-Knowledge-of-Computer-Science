
* 本文主要内容为**刘超**老师在极客时间上的《趣谈网络协议》课程学习笔记

----

>  UDP 适用于网络简单良好的情况， 而 TCP 适用于恶劣的网络环境


### TCP 包的头格式

![](https://github.com/LiuChuang0059/large_file/blob/master/pic/xxhcq.jpg)

* 源端口号 和目标端口号必不可少，确定数据发送的方向

* 包的序号： 解决 乱序的问题

* 确认序号 ： 发出去的包需要确认，解决不丢包的问题

* 状态位 ：
	* SYN 发起一个连接
    * ACK 回复
    * RST 重新连接
    * FIN 结束连接

* 窗口大小 ： 流量控制， 通信双方声明一个窗口，标识自己当前能够处理能力，


----


### 1. TCP 的三次握手 --- 连接建立

> 所有的问题都要建立一个连接，连接维护

```
A：您好，我是 A。

B：您好 A，我是 B。

A：您好 B。
```

> 请求 -> 应答 -> 应答之应答

#### 1. 为什么 3次

* A发起一个连接，发送了之后没有回复，有很多种可能，不能确认结果，会连续发送

* 终于 B 接收到了， 如果 B不愿意，  A 重试一阵后放弃， 如果 B愿意 ，发送应答包给 A

* 但是 对于 B 来说， 应答包不知道能不能到达 A， B 不能认为连接是建立好了

* 当 A接收到 B 发回的应答，A 就认为连接已经建立了； A 就会给 B发送应答之应答， B接收到回复，就算双方的消息都有去有回


#### 2. TCP 包 序号问题

* A 要告诉 B， 发起的包的序号从哪个号开始，B 同样要告诉 A； B 发起的包的序号从那个时候号开始

* 每个连接都有不同的序号， 起始序号随着时间变化，32位的计数器， 每 4 ms 加一
> IP 包 的头里面有个 TTL 生存时间， 上面的计数，4个小时才可能重复

----

#### 3. 建立连接的状态变化图

![](https://github.com/LiuChuang0059/large_file/blob/master/pic/q2xoa.jpg)

1. 开始都是处于 CLOSED 的状态

2. 服务端主动监听某个端口，处于 LISTEN

3. 客户端主动发起连接 SYN， 服务端收到 返回 SYN 并且 ACK（回复） 客户端的 SYN，之后处于 SYN-RCVD 状态

4. 客户端收到 SYN 和 ACK 发送 ACK 的 ACK ，之后处于 ESTABLISHED ，一收一发成功了

5. 服务端收到 ACK 的 ACK  之后处于 ESTABLISHED ，一收一发成功了

----

### 2. TCP 四次挥手 -- 断开连接

#### 1. 断开连接

```
A：B 啊，我不想玩了。

B：哦，你不想玩了啊，我知道了。
```

* 这个时候， A发完最后的数据， B 还可以发送数据，称为 半关闭的状态


```
B：A 啊，好吧，我也不玩了，拜拜

A：好的，拜拜。

```

* 这个时候，整个连接就关闭了


#### 2. 异常情况

* A 说完“不玩了”之后，直接跑， 然而 B还没有结束，即使 B发起结束，得不到应答
* A 说完“不玩了”，B 直接跑路，也是有问题的，因为 A 不知道 B是有事情处理，还是一会儿发送结束


#### 3. 状态时序图

![](https://github.com/LiuChuang0059/large_file/blob/master/pic/h1ca7.jpg)

1.   A 发送 关闭通知 进入 FIN-WAIT_1 , B 发送完 ACK之后 进入 COLSED_WAIT 状态

2.  A 收到 B 的 ACK ，就进入 FIN-WAIT_2
> 如果这个时候 B直接 跑路， A 将永远处于这个状态，TCP 没有对这个状态的处理， Linux 有，调整 tcp_fin_timeout  设置超时时间。

3. B 也发送 结束请求， ， A收到 发送 ACK 之后 从 FIN_WAIT_2 状态结束，
> 这个时候 A不能直接跑路， 因为  B可能接收不到 这个 ACK，B重新发送请求， A如果跑路了， B接收不到回复

4. TCP 协议 要求 A 最后等待一段时间
> MSL. 报文最大的生存时间 ： 任何报文在网络上存在的最长时间，超过报文会被丢弃

5. 如果超过了 2MSL的时间 B依然没有收到 ACK ；B重发 FIN ， A 那里直接发RST（重新连接）


------

### 3. TCP 状态机

![](https://github.com/LiuChuang0059/large_file/blob/master/pic/qn2n2.jpg)

> 阿拉伯数字是 连接过程的顺序； 中文数字序号是断开连接的顺序， 加醋实线是客户端状态的转移，虚线是服务端B的状态变化


-----

### 4. TCP 协议 发包模式

#### 1.发包模式

* 为了保证顺序性， 每个包都有一个  ID，商定了 起始 ID 然后按照 ID 一个个的发送

* 为了保证包不丢失， 发送到的包都要应答， 可以 **累积应答**
> 累计应答： 应答某个之前的ID，表示都收到了


* 需要记录 发送的和接收到的包， TCP 需要在发送端和接收端分别有缓存保存这些记录

	* 1. 发送了并且已经确认的
	* 2. 发送了，没有确认的
	* 3. 没有发送，但是等待发送
	* 4. 没有发送，暂时不会发送的

* 为什么分成 4 部分 ---- 流量控制
>  接收端会给发送端一个窗口的大小- -- Advertised Window =  2 + 3 即 交代了没完成和 马上要交代的


#### 2. 发送端数据结构
![](https://github.com/LiuChuang0059/large_file/blob/master/pic/lmaj4.jpg)

#### 3. 接收端数据结构
![](https://github.com/LiuChuang0059/large_file/blob/master/pic/sam21.jpg)

* 第一部分 ： 接收并确认， 交给给我并且做完的
* 第二部分 ： 还没接收，马上可以接收： 能够接收的最大工作量
* 三： 没办法接收，

**AdvertisedWindow=MaxRcvBuffer-((NextByteExpected-1)-LastByteRead**
> 一部分是， 还没被应用层读取到的部分占用的 MaxRcvBuffer -- 最大缓存量


---

### 5. TCP 确认和重发机制

#### 1. 超时重试
> 对每一个发送了，但是没有回复的包，设定一个定时器，超过一定的时间，就重新尝试

1. 超时时间的评估 -- 不宜过短或者过长

* 自适应重传算法
> 通过 采样RTT时间，进行加权平均，采样 RTT的波动范围；计算出一个估计的超时时间


#### 2. SACK
* 在 TCP 的头里面加入 SACK ，将缓存的地图发送到对方，立刻判断

#### 3. 快速重传机制

* 当接收方收到序号大于下一个所期望的报文时候，监测到 数据流有间隔，直接发送三个 ACK ； 客户端收到后，在定时器过期之前直接发送 报文
> 接收方发现 6、8、9 都已经接收了，就是 7 没来,于是发送三个 6 的 ACK，要求下一个是 7
客户端收到 3 个，就会发现 7 的确又丢了，不等超时，马上重发



----

### 6. TCP 流量控制 --- 滑动窗口 rwnd

1.  **发送端**窗口不变 为 9 ，当4 的确认到来的时候，窗口会向右 移动一个， 包13 就在可以发送的范围了

![](https://github.com/LiuChuang0059/large_file/blob/master/pic/z1cy0.jpg)

2. 假如 **发送端**发送过快，直接将 10，11，12，13 全部发送完毕，之后就停止发送，没有可以发送的包了

![](https://github.com/LiuChuang0059/large_file/blob/master/pic/bba01.jpg)

3.  当包 5 确认到达的时候，**发送端**向右滑动一格，有更多的包可以发送 包14 发送

![](https://github.com/LiuChuang0059/large_file/blob/master/pic/kwi5l.jpg)


----

* 假设接收端处理的是在太慢，导致缓存中没有空间，可以通过确认信息修改窗口的大小，设置为0 发送方就停止发送

4. 假如应用一直不读取缓存中的数据，当数据包 6 确认后， 窗口缩小为8

![](https://github.com/LiuChuang0059/large_file/blob/master/pic/sr6cy.jpg)

5. 新的窗口大小8 通过 6 的确认消息发送到**发送端**， 发送端的窗口从9 - 8

![](https://github.com/LiuChuang0059/large_file/blob/master/pic/ci6es.jpg)

6. 接收端一直没有处理数据，窗口越来越小，直到0
![](https://github.com/LiuChuang0059/large_file/blob/master/pic/xz1yo.jpg)

![](https://github.com/LiuChuang0059/large_file/blob/master/pic/y31d9.jpg)

> 窗口变为 0 ，发送发回发送窗口探测数据包，是否有机会调整窗口大小
> 最好， 不立刻更新窗口， 当窗口太小的时候，不更新窗口，直到达到一定大小，例如缓冲区的一半，再更新窗口

----

### 7. TCP 拥塞控制问题 --- cwnd

> 拥塞窗口,防止网络塞满。TCP 由于不知道网络路径，相当于一个黑盒。TCP 发送包类似于向水管里面灌水， 拥塞控制就是在不堵塞不丢包的情况下，尽量发挥带宽的作用
> 带宽： 每秒钟能发送多少数据
> 通道的容量 = 带宽 × 往返延迟。-- 相当于水管长度

**拥塞窗口和滑动窗口共同控制发送的速度**



![](https://github.com/LiuChuang0059/large_file/blob/master/pic/6p4t7.jpg)

* 发送未确认的包为通道的容量，可以装满整个通道

	* 每秒发送一个包，8 秒后，8个包都发送了出去，4个一级ing接收确认，发送了 ACK ；只不过 ACK还没到发送端

	* 5-8 还没接收

* 假如调大窗口
	* 发送的速度更快， 单位时间更多的包通过，处理不完，多出来的包会被丢弃--**包丢失**

	* 假如在中间设备假如缓存，来不及处理的包，在队列里面排队等着，会增加延时--- **超时重传**

* TCP 拥塞机制 主要就是	为了防止上面的现象发生



#### 1. 确认窗口大小--- 慢启动传统算法

* 一开始 慢慢加速， 当收到确认，就指数性的增长 1，2 4 8 16

* ssthresh 达到65535  速度慢下来， 线性增长 每次加1

* 直到出现拥塞现象。慢慢降低速度

* 一旦发生丢包现象，  sshresh 设定为 cwnd/2  重新开始满启动


#### 2. 快速重传算法

* 当丢包了， cwnd 减半， ssthresh = cwnd, 发送前一个包的 ACK 3 次，

* 当三个包返回的时候， cwnd = sshthresh +3

![](https://github.com/LiuChuang0059/large_file/blob/master/pic/lrq89.jpg)


#### 3. 存在的问题

* **丢包** 不一定就是通道满了，带宽不满也可能对包

* **缓存的问题** TCP 不应该等到将设备的缓存也填满了才降速

#### 4. TCP BBR 拥塞算法
> 管道填满，但是不填满延时

![](https://github.com/LiuChuang0059/large_file/blob/master/pic/aarek.jpg)






























































